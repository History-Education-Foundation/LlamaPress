<script data-llama="exclude_when_saving_contenteditable_edits">
document.addEventListener('DOMContentLoaded', () => {
    // Make the entire body editable, except for elements with the specific data-llama attribute
    document.body.contentEditable = true;

    // Find all elements with the data-llama attribute and make them non-editable
    const nonEditableElements = document.querySelectorAll('[data-llama*="exclude_when_saving_contenteditable_edits"]');
    nonEditableElements.forEach(element => {
        element.contentEditable = false;
    });

    let isEditing = false;
    let originalContent = '';
    let saveTimeout;

    // Function to save changes
    function saveChanges() {
        let currentContent = document.documentElement.outerHTML;
        // Only save if content has changed
        if (currentContent !== originalContent) {

            const clonedDoc = document.cloneNode(true);
        
            // Update the selector to use attribute contains selector
            const nodesToExclude = clonedDoc.querySelectorAll('[data-llama*="exclude_when_saving_contenteditable_edits"]');
            nodesToExclude.forEach(node => {
                node.remove();
            });

            // Get the cleaned HTML content
            let cleanedContent = clonedDoc.documentElement.outerHTML;
            //also, remove the contenteditable="true" attribute from the body
            cleanedContent = cleanedContent.replace('contenteditable="true"', '');

            // Use a more modern confirmation dialog
            if (confirm('Save these changes?')) {
                // Show a loading indicator
                const loadingIndicator = document.createElement('div');
                loadingIndicator.textContent = 'Saving...';
                loadingIndicator.style.position = 'fixed';
                loadingIndicator.style.top = '10px';
                loadingIndicator.style.right = '10px';
                loadingIndicator.style.padding = '10px';
                loadingIndicator.style.background = 'rgba(0,0,0,0.7)';
                loadingIndicator.style.color = 'white';
                loadingIndicator.style.borderRadius = '5px';
                document.body.appendChild(loadingIndicator);

                fetch('/pages/<%= @page&.id %>.json', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: cleanedContent }),
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Save successful:', data);
                    originalContent = cleanedContent; // Update original content after successful save
                    alert('Changes saved successfully!');
                })
                .catch((error) => {
                    console.error('Error saving changes:', error);
                    alert('Error saving changes. Please try again.');
                })
                .finally(() => {
                    // Remove the loading indicator
                    document.body.removeChild(loadingIndicator);
                });
            } else {
                document.body.innerHTML = originalContent; // Revert to original content
                console.log('Changes discarded');
            }
        }
    }

    // Event listener for when editing starts
    document.body.addEventListener('focus', (event) => {
        if (event.target.isContentEditable) {
            originalContent = document.body.innerHTML;
            isEditing = false;
        }
    }, true);

    // Event listener for changes
    document.body.addEventListener('input', (event) => {
        if (event.target.isContentEditable) {
            isEditing = true;
            
            // Clear the existing timeout
            clearTimeout(saveTimeout);
            
            // Set a new timeout to save changes after 2 seconds of inactivity
            saveTimeout = setTimeout(saveChanges, 2000);
        }
    }, true);

    // Event listener for when editing ends
    document.body.addEventListener('blur', (event) => {
        if (event.target.isContentEditable && isEditing) {
            clearTimeout(saveTimeout); // Clear any pending save
            saveChanges(); // Save immediately on blur
            isEditing = false;
        }
    }, true);

    // Listen for page unload to save any unsaved changes
    window.addEventListener('beforeunload', (event) => {
        if (isEditing) {
            saveChanges();
            event.preventDefault(); // Cancel the event
            event.returnValue = ''; // Display a default message in most browsers
        }
    });
});
</script>